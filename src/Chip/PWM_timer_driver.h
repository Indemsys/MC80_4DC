#ifndef PWM_TIMER_DRIVER_H
#define PWM_TIMER_DRIVER_H

// Complete GPT register bitfield type definitions (based on official FSP R7FA8M1AH.h)
typedef struct
{
  uint32_t CST : 1;   // [0]     Count Start
  uint32_t : 15;      // [15:1]  Reserved (must be written as 0)
  uint32_t MD : 4;    // [19:16] Mode Select
  uint32_t : 3;       // [22:20] Reserved (must be written as 0)
  uint32_t TPCS : 4;  // [26:23] Timer Prescaler Select
  uint32_t : 5;       // [31:27] Reserved (must be written as 0)
} T_gtcr_bits;

// -----------------------------------------------------------------------------
// GTUDDTYC – General PWM Timer Count-Direction & Duty-Setting Register
//
// Purpose
//   • Real-time control of GTCNT count direction (UD / UDF).
//   • Per-output “duty override” that can pin GTIOA / GTIOB to 0 % or 100 %,
//     then re-enter PWM either immediately or at the next compare-match.
//
// Notes
//   • All reserved bits must be written as 0.
//   • Register writes are ignored while the GPT is in “event-count” operation.
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// Detailed field description for GTUDDTYC duty-override logic
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// OADTY[1:0] – GTIOCnA Output Duty Setting
//
// 00 / 01  Duty is generated by the normal compare-match mechanism (PWM).
// 10       Force 0 % duty – GTIOA is held LOW while OADTYF = 1.
// 11       Force 100 % duty – GTIOA is held HIGH while OADTYF = 1.
//
// NOTE 1: The chosen value reaches the pin only while OADTYF = 1.
// NOTE 2: Codes 00 and 01 are electrically identical; they differ only when
//         GTIOR.GTIOA[3:2] masks are used.
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// OADTYF – Forcible GTIOCnA Output Duty Setting Enable
//
// 0  Normal operation – PWM engine drives GTIOA, OADTY[1:0] is ignored.
// 1  PWM engine is disconnected.  GTIOA is driven permanently to the level
//    selected by OADTY[1:0] starting at the next GPT clock edge.
//
// • This is the main “override switch”.  Use it for motor-brake, BLDC align,
//   or any condition where the pin must ignore compare events.
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// OADTYR – GTIOCnA Output Value Select after releasing 0 % / 100 % duty
//
// 0  When OADTYF is cleared to 0, the pin immediately obeys the function
//    selected by GTIOR.GTIOA[3:2] at the next cycle-end
//    (overflow if counting up, underflow if counting down).
//
// 1  When OADTYF is cleared to 0, the forced level is retained UNTIL the first
//    compare-match A or B occurs; the match event then toggles/sets the pin.
//    Choose this to re-enter PWM without a single-cycle glitch.
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// OBDTY[1:0] – GTIOCnB Output Duty Setting
//
// Coding and behaviour are IDENTICAL to OADTY[1:0] but apply to the GTIOB pin.
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// OBDTYF – Forcible GTIOCnB Output Duty Setting Enable
//
// Same semantics as OADTYF, acting on GTIOB.
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// OBDTYR – GTIOCnB Output Value Select after releasing 0 % / 100 % duty
//
// Same semantics as OADTYR, acting on GTIOB.
// -----------------------------------------------------------------------------
// HINTS FOR USE:
//
// • To put both half-bridge legs in LOW state:
//      clear OADTY[1:0] & OBDTY[1:0] to 10b
//      set  OADTYF and OBDTYF to 1
//
// • To resume PWM WITHOUT a spike:
//      set  OADTYR / OBDTYR to 1
//      clear OADTYF / OBDTYF in the same write or right after
//
// • To resume PWM IMMEDIATELY (may generate a narrow pulse):
//      leave OADTYR / OBDTYR at 0, then clear OADTYF / OBDTYF.
//
// • Fields may be written at any time; however, writes are ignored while the
//   GPT is in event-count operation.
typedef struct
{
  // ─────────────────────────────────────────────────────────────────────────
  uint32_t UD : 1;   // [0]  Count Direction
                     //      0 → GTCNT counts DOWN toward 0.
                     //      1 → GTCNT counts UP   toward GTPR.
                     //      • Saw-wave: a software write takes effect only
                     //        after the next overflow / underflow.
                     //      • Triangle: direction cannot change mid-cycle
                     //        unless UDF = 1 (see below).

  uint32_t UDF : 1;  // [1]  Forcible Count Direction Setting
                     //      0 → UD is sampled only when the timer starts.
                     //      1 → The current value of UD is applied
                     //        IMMEDIATELY, even while counting is active.
                     //      • Typical use: emergency phase reversal or
                     //        “freeze” of a saw-wave in one direction.
                     //      • Must be cleared back to 0 BEFORE the next
                     //        GTSTR start, otherwise UD will stay forced.

  uint32_t : 14;     // [15:2] Reserved (write 0)

  // ───── GTIOA duty-override (upper-side FET) ─────────────────────────────
  uint32_t OADTY : 2;   // [17:16] GTIOA Duty Selection
                        //      00 / 01 → PWM from compare-match (normal mode)
                        //      10      → Constant LOW  (0 % duty)
                        //      11      → Constant HIGH (100 % duty)
                        //      • The selected value only reaches the pin when
                        //        OADTYF = 1.

  uint32_t OADTYF : 1;  // [18]  Forcible GTIOA Duty Enable
                        //      0 → PWM engine drives GTIOA (OADTY ignored).
                        //      1 → PWM engine is disconnected; GTIOA is held
                        //        at the level specified by OADTY.
                        //      • Level changes at the next GPT clock edge.

  uint32_t OADTYR : 1;  // [19]  GTIOA Resume-Mode after 0 % / 100 %
                        //      0 → Upon clearing OADTYF, the function defined
                        //        in GTIOR.GTIOA[3:2] is applied AT CYCLE END
                        //        (overflow / underflow).
                        //      1 → GTIOA keeps its forced level until the
                        //        FIRST COMPARE-MATCH A/B after OADTYF = 0.
                        //      • Use ‘1’ for a “glitch-free” return to PWM.

  uint32_t : 4;         // [23:20] Reserved

  // ───── GTIOB duty-override (lower-side FET) ─────────────────────────────
  uint32_t OBDTY : 2;   // [25:24] GTIOB Duty Selection (coding = OADTY)
  uint32_t OBDTYF : 1;  // [26]    Forcible GTIOB Duty Enable      (same role)
  uint32_t OBDTYR : 1;  // [27]    GTIOB Resume-Mode              (same role)

  uint32_t : 4;         // [31:28] Reserved
} T_gtuddtyc_bits;


// -----------------------------------------------------------------------------
// GTST – General PWM Timer Status Register
//
//  • “RW1”  bits are *write-1-to-clear* latches: write 1 → flag is cleared.
//  • Plain “R” bits are read-only status.
//  • Reserved bits must be written as 0.
// -----------------------------------------------------------------------------
typedef struct
{
    uint32_t TCFA   : 1;  // [0]  Input-capture / compare-match flag A        (RW1)
                          //      0 = no GTCCRA match
                          //      1 = GTCCRA match/capture occurred

    uint32_t TCFB   : 1;  // [1]  Flag B  (GTCCRB)                            (RW1)
    uint32_t TCFC   : 1;  // [2]  Flag C  (GTCCRC)                            (RW1)
    uint32_t TCFD   : 1;  // [3]  Flag D  (GTCCRD)                            (RW1)
    uint32_t TCFE   : 1;  // [4]  Flag E  (GTCCRE)                            (RW1)
    uint32_t TCFF   : 1;  // [5]  Flag F  (GTCCRF)                            (RW1)

    uint32_t TCFPO  : 1;  // [6]  Overflow (crest) flag                       (RW1)
                          //      1 = counter reached GTPR while counting up

    uint32_t TCFPU  : 1;  // [7]  Underflow (trough) flag                     (RW1)
                          //      1 = counter reached 0 while counting down

    uint32_t        : 7;  // [14:8] Reserved

    uint32_t TUCF   : 1;  // [15] Count-direction status (Read-only)
                          //      0 = down-counting, 1 = up-counting

    uint32_t ADTRAUF: 1;  // [16] GTADTRA compare-match (up-count) flag       (RW1)
    uint32_t ADTRADF: 1;  // [17] GTADTRA compare-match (down-count) flag     (RW1)
    uint32_t ADTRBUF: 1;  // [18] GTADTRB compare-match (up-count) flag       (RW1)
    uint32_t ADTRBDF: 1;  // [19] GTADTRB compare-match (down-count) flag     (RW1)

    uint32_t        : 4;  // [23:20] Reserved

    uint32_t ODF    : 1;  // [24] Output-disable request flag                 (Read-only)
                          //      1 = POEG asserted or GPT error triggered

    uint32_t        : 4;  // [28:25] Reserved

    uint32_t OABHF  : 1;  // [29] Same-time output-level-HIGH flag            (Read-only)
                          //      1 = GTIOA and GTIOB were HIGH simultaneously

    uint32_t OABLF  : 1;  // [30] Same-time output-level-LOW flag             (Read-only)
                          //      1 = GTIOA and GTIOB were LOW simultaneously

    uint32_t PCF    : 1;  // [31] Period-count function finish flag           (RW1)
                          //      1 = period function completed (GPT32/16 only)
} T_gtst_bits;


// GTADSMR : General PWM Timer A/D Conversion Start Request Signal Monitoring Register
typedef struct
{
  uint32_t ADSMS0 : 2;   // [1:0]  A/D-conversion start-request source for Monitor-0
                         //        00 = GTADTRA during up-count
                         //        01 = GTADTRA during down-count
                         //        10 = GTADTRB during up-count
                         //        11 = GTADTRB during down-count
  uint32_t : 6;          // [7:2]  Reserved (write 0, reads 0)

  uint32_t ADSMEN0 : 1;  // [8]    Monitor-0 output enable (to GTADSM0 pin)
                         //        0 = disabled (pin low)
                         //        1 = enabled
  uint32_t : 7;          // [15:9] Reserved

  uint32_t ADSMS1 : 2;   // [17:16] A/D-conversion start-request source for Monitor-1
                         //        (encoding identical to ADSMS0)
  uint32_t : 6;          // [23:18] Reserved

  uint32_t ADSMEN1 : 1;  // [24]   Monitor-1 output enable (to GTADSM1 pin)
  uint32_t : 7;          // [31:25] Reserved
} T_gtadsmr_bits;

typedef struct
{
  uint32_t SSGTRGAR : 1;  // [0..0] GTETRG Pin Rising Input Source Counter Start Enable
  uint32_t SSGTRGAF : 1;  // [1..1] GTETRG Pin Falling Input Source Counter Start Enable
  uint32_t SSGTRGBR : 1;  // [2..2] GTETRG Pin Rising Input Source Counter Start Enable
  uint32_t SSGTRGBF : 1;  // [3..3] GTETRG Pin Falling Input Source Counter Start Enable
  uint32_t SSGTRGCR : 1;  // [4..4] GTETRG Pin Rising Input Source Counter Start Enable
  uint32_t SSGTRGCF : 1;  // [5..5] GTETRG Pin Falling Input Source Counter Start Enable
  uint32_t SSGTRGDR : 1;  // [6..6] GTETRG Pin Rising Input Source Counter Start Enable
  uint32_t SSGTRGDF : 1;  // [7..7] GTETRG Pin Falling Input Source Counter Start Enable
  uint32_t SSCARBL : 1;   // [8..8] GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Start Enable
  uint32_t SSCARBH : 1;   // [9..9] GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Start Enable
  uint32_t SSCAFBL : 1;   // [10..10] GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Start Enable
  uint32_t SSCAFBH : 1;   // [11..11] GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Start Enable
  uint32_t SSCBRAL : 1;   // [12..12] GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Start Enable
  uint32_t SSCBRAH : 1;   // [13..13] GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Start Enable
  uint32_t SSCBFAL : 1;   // [14..14] GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Start Enable
  uint32_t SSCBFAH : 1;   // [15..15] GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Start Enable
  uint32_t SSELCA : 1;    // [16..16] ELC_GPT Event Source Counter Start Enable
  uint32_t SSELCB : 1;    // [17..17] ELC_GPT Event Source Counter Start Enable
  uint32_t SSELCC : 1;    // [18..18] ELC_GPT Event Source Counter Start Enable
  uint32_t SSELCD : 1;    // [19..19] ELC_GPT Event Source Counter Start Enable
  uint32_t SSELCE : 1;    // [20..20] ELC_GPT Event Source Counter Start Enable
  uint32_t SSELCF : 1;    // [21..21] ELC_GPT Event Source Counter Start Enable
  uint32_t SSELCG : 1;    // [22..22] ELC_GPT Event Source Counter Start Enable
  uint32_t SSELCH : 1;    // [23..23] ELC_GPT Event Source Counter Start Enable
  uint32_t : 7;
  uint32_t CSTRT : 1;     // [31..31] Software Source Counter Start Enable
} T_gtssr_bits;

typedef struct
{
  uint32_t PSGTRGAR : 1;  // [0..0] GTETRG Pin Rising Input Source Counter Stop Enable
  uint32_t PSGTRGAF : 1;  // [1..1] GTETRG Pin Falling Input Source Counter Stop Enable
  uint32_t PSGTRGBR : 1;  // [2..2] GTETRG Pin Rising Input Source Counter Stop Enable
  uint32_t PSGTRGBF : 1;  // [3..3] GTETRG Pin Falling Input Source Counter Stop Enable
  uint32_t PSGTRGCR : 1;  // [4..4] GTETRG Pin Rising Input Source Counter Stop Enable
  uint32_t PSGTRGCF : 1;  // [5..5] GTETRG Pin Falling Input Source Counter Stop Enable
  uint32_t PSGTRGDR : 1;  // [6..6] GTETRG Pin Rising Input Source Counter Stop Enable
  uint32_t PSGTRGDF : 1;  // [7..7] GTETRG Pin Falling Input Source Counter Stop Enable
  uint32_t PSCARBL : 1;   // [8..8] GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Stop Enable
  uint32_t PSCARBH : 1;   // [9..9] GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Stop Enable
  uint32_t PSCAFBL : 1;   // [10..10] GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Stop Enable
  uint32_t PSCAFBH : 1;   // [11..11] GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Stop Enable
  uint32_t PSCBRAL : 1;   // [12..12] GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Stop Enable
  uint32_t PSCBRAH : 1;   // [13..13] GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Stop Enable
  uint32_t PSCBFAL : 1;   // [14..14] GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Stop Enable
  uint32_t PSCBFAH : 1;   // [15..15] GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Stop Enable
  uint32_t PSELCA : 1;    // [16..16] ELC_GPTA Event Source Counter Stop Enable
  uint32_t PSELCB : 1;    // [17..17] ELC_GPTA Event Source Counter Stop Enable
  uint32_t PSELCC : 1;    // [18..18] ELC_GPTA Event Source Counter Stop Enable
  uint32_t PSELCD : 1;    // [19..19] ELC_GPTA Event Source Counter Stop Enable
  uint32_t PSELCE : 1;    // [20..20] ELC_GPTA Event Source Counter Stop Enable
  uint32_t PSELCF : 1;    // [21..21] ELC_GPTA Event Source Counter Stop Enable
  uint32_t PSELCG : 1;    // [22..22] ELC_GPTA Event Source Counter Stop Enable
  uint32_t PSELCH : 1;    // [23..23] ELC_GPTA Event Source Counter Stop Enable
  uint32_t : 7;
  uint32_t CSTOP : 1;     // [31..31] Software Source Counter Stop Enable
} T_gtpsr_bits;

typedef struct
{
  uint32_t CSGTRGAR : 1;  // [0..0] GTETRG Pin Rising Input Source Counter Clear Enable
  uint32_t CSGTRGAF : 1;  // [1..1] GTETRG Pin Falling Input Source Counter Clear Enable
  uint32_t CSGTRGBR : 1;  // [2..2] GTETRG Pin Rising Input Source Counter Clear Enable
  uint32_t CSGTRGBF : 1;  // [3..3] GTETRG Pin Falling Input Source Counter Clear Enable
  uint32_t CSGTRGCR : 1;  // [4..4] GTETRG Pin Rising Input Source Counter Clear Enable
  uint32_t CSGTRGCF : 1;  // [5..5] GTETRG Pin Falling Input Source Counter Clear Enable
  uint32_t CSGTRGDR : 1;  // [6..6] GTETRG Pin Rising Input Source Counter Clear Enable
  uint32_t CSGTRGDF : 1;  // [7..7] GTETRG Pin Falling Input Source Counter Clear Enable
  uint32_t CSCARBL : 1;   // [8..8] GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Clear Enable
  uint32_t CSCARBH : 1;   // [9..9] GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Clear Enable
  uint32_t CSCAFBL : 1;   // [10..10] GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Clear Enable
  uint32_t CSCAFBH : 1;   // [11..11] GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Clear Enable
  uint32_t CSCBRAL : 1;   // [12..12] GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Clear Enable
  uint32_t CSCBRAH : 1;   // [13..13] GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Clear Enable
  uint32_t CSCBFAL : 1;   // [14..14] GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Clear Enable
  uint32_t CSCBFAH : 1;   // [15..15] GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Clear Enable
  uint32_t CSELCA : 1;    // [16..16] ELC_GPTA Event Source Counter Clear Enable
  uint32_t CSELCB : 1;    // [17..17] ELC_GPTA Event Source Counter Clear Enable
  uint32_t CSELCC : 1;    // [18..18] ELC_GPTA Event Source Counter Clear Enable
  uint32_t CSELCD : 1;    // [19..19] ELC_GPTA Event Source Counter Clear Enable
  uint32_t CSELCE : 1;    // [20..20] ELC_GPTA Event Source Counter Clear Enable
  uint32_t CSELCF : 1;    // [21..21] ELC_GPTA Event Source Counter Clear Enable
  uint32_t CSELCG : 1;    // [22..22] ELC_GPTA Event Source Counter Clear Enable
  uint32_t CSELCH : 1;    // [23..23] ELC_GPTA Event Source Counter Clear Enable
  uint32_t CSCMSC : 3;    // [26..24] Compare Match/Input Capture/Synchronous counter clearing Source Counter Clear Enable
  uint32_t CP1CCE : 1;    // [27..27] Complementary PWM mode1 Crest Source Counter Clear Enable
  uint32_t : 3;
  uint32_t CCLR : 1;      // [31..31] Software Source Counter Clear Enable
} T_gtcsr_bits;

typedef struct
{
  uint32_t TDE : 1;  // [0] Negative-Phase Waveform Setting
  uint32_t : 31;     // [31:1] Reserved (read as 0, write as 0)
} T_gtdtcr_bits;

typedef struct
{
  uint32_t GTDVU : 32;  // [31..0] Dead Time Value Register U
} T_gtdvu_bits;

//  GTBER – General PWM Timer Buffer Enable Register
typedef struct
{
  //--- Basic “disable” flags --------------------------------
  uint32_t BD0 : 1;  // [0]  GTCCR   buffer-operation disable
                     //        0 = buffer operation **enabled**
                     //        1 = buffer operation **disabled**
  uint32_t BD1 : 1;  // [1]  GTPR    buffer-operation disable
                     //        0 = enabled
                     //        1 = disabled
  uint32_t BD2 : 1;  // [2]  GTADTRA / GTADTRB buffer-operation disable
                     //        0 = enabled
                     //        1 = disabled

  uint32_t : 13;     // [15:3]  Reserved – always write 0

  //--- GTCCR / GTPR buffer modes -----------------------------------------------
  uint32_t CCRA : 2;    // [17:16] GTCCRA buffer-operation mode
                        //        00 = No buffering
                        //        01 = **Single**  buffer  (GTCCRA  ↔  GTCCRC)
                        //        1x = **Double** buffer  (GTCCRA  ↔  GTCCRC  ↔  GTCCRD)

  uint32_t CCRB : 2;    // [19:18] GTCCRB buffer-operation mode
                        //        00 = No buffering
                        //        01 = Single  (GTCCRB ↔ GTCCRE)
                        //        1x = Double  (GTCCRB ↔ GTCCRE ↔ GTCCRF)

  uint32_t PR : 2;      // [21:20] GTPR buffer-operation mode
                        //        00 = No buffering
                        //        01 = Single  (GTPRB  ↔  GTPR)
                        //        1x = **Prohibited / Reserved**

  uint32_t CCRSWT : 1;  // [22]  GTCCRA & GTCCRB *forcible* buffer transfer
                        //        Write 1 → immediate transfer, then bit autonegates to 0

  uint32_t : 1;         // [23]  Reserved

  //--- A/D-trigger buffer timing & depth ---------------------------------------
  uint32_t ADTTA : 2;  // [25:24] GTADTRA transfer-timing select
                       //        00 = Triangle-wave : no transfer
                       //             Saw-wave      : no transfer
                       //        01 = Triangle-wave : **crest**
                       //             Saw-wave      : underflow (down) / overflow (up) / clr
                       //        10 = Triangle-wave : **trough**
                       //             Saw-wave      : underflow (down) / overflow (up) / clr
                       //        11 = Triangle-wave : crest **and** trough
                       //             Saw-wave      : underflow (up) / overflow (down) / clr

  uint32_t ADTDA : 1;  // [26]  GTADTRA double-buffer enable
                       //        0 = Single buffer   (GTADTDBRA → GTADTRA)
                       //        1 = Double buffer   (GTADTDBRA → GTADTDBRA → GTADTRA)

  uint32_t : 1;        // [27]  Reserved

  uint32_t ADTTB : 2;  // [29:28] GTADTRB transfer-timing select
                       //        Coding **идентична ADTTA** (см. выше)

  uint32_t ADTDB : 1;  // [30]  GTADTRB double-buffer enable
                       //        0 = Single buffer   (GTADTDBRB → GTADTRB)
                       //        1 = Double buffer   (GTADTDBRB → GTADTDBRB → GTADTRB)

  uint32_t : 1;        // [31]  Reserved
} T_gtber_bits;

typedef struct
{
  uint32_t GTIOA : 5;   // [4:0]   GTIOCnA Pin Function Select
  uint32_t : 1;         // [5]     Reserved (write as 0)
  uint32_t OADFLT : 1;  // [6]     GTIOCnA Pin Output Value Setting at the Count Stop
  uint32_t OAHLD : 1;   // [7]     GTIOCnA Pin Output Setting at the Start/Stop Count
  uint32_t OAE : 1;     // [8]     GTIOCnA Pin Output Enable
  uint32_t OADF : 2;    // [10:9]  GTIOCnA Pin Disable Value Setting
  uint32_t : 2;         // [12:11] Reserved (write as 0)
  uint32_t NFAEN : 1;   // [13]    Noise Filter A Enable
  uint32_t NFCSA : 2;   // [15:14] Noise Filter A Sampling Clock Select
  uint32_t GTIOB : 5;   // [20:16] GTIOCnB Pin Function Select
  uint32_t : 1;         // [21]    Reserved (write as 0)
  uint32_t OBDFLT : 1;  // [22]    GTIOCnB Pin Output Value Setting at the Count Stop
  uint32_t OBHLD : 1;   // [23]    GTIOCnB Pin Output Setting at the Start/Stop Count
  uint32_t OBE : 1;     // [24]    GTIOCnB Pin Output Enable
  uint32_t OBDF : 2;    // [26:25] GTIOCnB Pin Disable Value Setting
  uint32_t : 2;         // [28:27] Reserved (write as 0)
  uint32_t NFBEN : 1;   // [29]    Noise Filter B Enable
  uint32_t NFCSB : 2;   // [31:30] Noise Filter B Sampling Clock Select
} T_gtior_bits;

typedef struct
{
  uint32_t : 16;          // [15:0]  Reserved
  uint32_t ADTRAUEN : 1;  // [16]    GTADTRA up-count compare → A/D start enable
  uint32_t ADTRADEN : 1;  // [17]    GTADTRA down-count compare → A/D start enable
  uint32_t ADTRBUEN : 1;  // [18]    GTADTRB up-count compare → A/D start enable
  uint32_t ADTRBDEN : 1;  // [19]    GTADTRB down-count compare → A/D start enable
  uint32_t : 4;           // [23:20] Reserved
  uint32_t GRP : 2;       // [25:24] Output-disable source select (00=A,01=B,10=C,11=D)
  uint32_t : 3;           // [28:26] Reserved
  uint32_t GRPABH : 1;    // [29]    “Same-time HIGH” disable-request enable
  uint32_t GRPABL : 1;    // [30]    “Same-time LOW”  disable-request enable
  uint32_t : 1;           // [31]    Reserved
} T_gtintad_bits;

// MSTPCRE register bitfield structure for Module Stop Control Register E
typedef struct
{
  uint32_t MSTPCRE0 : 1;   // [0..0] Module Stop Control Register E bit 0
  uint32_t MSTPCRE1 : 1;   // [1..1] Module Stop Control Register E bit 1
  uint32_t MSTPCRE2 : 1;   // [2..2] Module Stop Control Register E bit 2
  uint32_t MSTPCRE3 : 1;   // [3..3] Module Stop Control Register E bit 3
  uint32_t MSTPCRE4 : 1;   // [4..4] Module Stop Control Register E bit 4
  uint32_t MSTPCRE5 : 1;   // [5..5] Module Stop Control Register E bit 5
  uint32_t MSTPCRE6 : 1;   // [6..6] Module Stop Control Register E bit 6
  uint32_t MSTPCRE7 : 1;   // [7..7] Module Stop Control Register E bit 7
  uint32_t MSTPCRE8 : 1;   // [8..8] Module Stop Control Register E bit 8
  uint32_t MSTPCRE9 : 1;   // [9..9] Module Stop Control Register E bit 9
  uint32_t MSTPCRE10 : 1;  // [10..10] Module Stop Control Register E bit 10
  uint32_t MSTPCRE11 : 1;  // [11..11] Module Stop Control Register E bit 11
  uint32_t MSTPCRE12 : 1;  // [12..12] Module Stop Control Register E bit 12
  uint32_t MSTPCRE13 : 1;  // [13..13] Module Stop Control Register E bit 13
  uint32_t MSTPCRE14 : 1;  // [14..14] Module Stop Control Register E bit 14
  uint32_t MSTPCRE15 : 1;  // [15..15] Module Stop Control Register E bit 15
  uint32_t MSTPCRE16 : 1;  // [16..16] Module Stop Control Register E bit 16
  uint32_t MSTPCRE17 : 1;  // [17..17] Module Stop Control Register E bit 17
  uint32_t MSTPCRE18 : 1;  // [18..18] Module Stop Control Register E bit 18
  uint32_t MSTPCRE19 : 1;  // [19..19] Module Stop Control Register E bit 19
  uint32_t MSTPCRE20 : 1;  // [20..20] Module Stop Control Register E bit 20
  uint32_t MSTPCRE21 : 1;  // [21..21] Module Stop Control Register E bit 21
  uint32_t MSTPCRE22 : 1;  // [22..22] Module Stop Control Register E bit 22
  uint32_t MSTPCRE23 : 1;  // [23..23] Module Stop Control Register E bit 23
  uint32_t MSTPCRE24 : 1;  // [24..24] Module Stop Control Register E bit 24
  uint32_t MSTPCRE25 : 1;  // [25..25] Module Stop Control Register E bit 25
  uint32_t MSTPCRE26 : 1;  // [26..26] GPT5 Module Stop Control (0=Enable, 1=Disable/Stop)
  uint32_t MSTPCRE27 : 1;  // [27..27] GPT4 Module Stop Control (0=Enable, 1=Disable/Stop)
  uint32_t MSTPCRE28 : 1;  // [28..28] GPT3 Module Stop Control (0=Enable, 1=Disable/Stop)
  uint32_t MSTPCRE29 : 1;  // [29..29] GPT2 Module Stop Control (0=Enable, 1=Disable/Stop)
  uint32_t MSTPCRE30 : 1;  // [30..30] GPT1 Module Stop Control (0=Enable, 1=Disable/Stop)
  uint32_t MSTPCRE31 : 1;  // [31..31] GPT0 Module Stop Control (0=Enable, 1=Disable/Stop)
} T_mstpcre_bits;

typedef union
{
  uint32_t       reg;
  T_mstpcre_bits bf;
} T_reg_MSTPCRE;

// GTSTR register bitfield structure for GPT Start Register
typedef struct
{
  uint32_t CSTRT0 : 1;   // [0..0] GPT0 Channel Start (1=Start, 0=No effect)
  uint32_t CSTRT1 : 1;   // [1..1] GPT1 Channel Start (1=Start, 0=No effect)
  uint32_t CSTRT2 : 1;   // [2..2] GPT2 Channel Start (1=Start, 0=No effect)
  uint32_t CSTRT3 : 1;   // [3..3] GPT3 Channel Start (1=Start, 0=No effect)
  uint32_t CSTRT4 : 1;   // [4..4] GPT4 Channel Start (1=Start, 0=No effect)
  uint32_t CSTRT5 : 1;   // [5..5] GPT5 Channel Start (1=Start, 0=No effect)
  uint32_t CSTRT6 : 1;   // [6..6] GPT6 Channel Start (1=Start, 0=No effect)
  uint32_t CSTRT7 : 1;   // [7..7] GPT7 Channel Start (1=Start, 0=No effect)
  uint32_t CSTRT8 : 1;   // [8..8] GPT8 Channel Start (1=Start, 0=No effect)
  uint32_t CSTRT9 : 1;   // [9..9] GPT9 Channel Start (1=Start, 0=No effect)
  uint32_t CSTRT10 : 1;  // [10..10] GPT10 Channel Start (1=Start, 0=No effect)
  uint32_t CSTRT11 : 1;  // [11..11] GPT11 Channel Start (1=Start, 0=No effect)
  uint32_t CSTRT12 : 1;  // [12..12] GPT12 Channel Start (1=Start, 0=No effect)
  uint32_t CSTRT13 : 1;  // [13..13] GPT13 Channel Start (1=Start, 0=No effect)
  uint32_t : 18;         // [14..31] Reserved
} T_gtstr_bits;

typedef union
{
  uint32_t     reg;
  T_gtstr_bits bf;
} T_reg_GTSTR;

// GTSTP register bitfield structure for GPT Stop Register
typedef struct
{
  uint32_t CSTOP0 : 1;   // [0..0] GPT0 Channel Stop (1=Stop, 0=No effect)
  uint32_t CSTOP1 : 1;   // [1..1] GPT1 Channel Stop (1=Stop, 0=No effect)
  uint32_t CSTOP2 : 1;   // [2..2] GPT2 Channel Stop (1=Stop, 0=No effect)
  uint32_t CSTOP3 : 1;   // [3..3] GPT3 Channel Stop (1=Stop, 0=No effect)
  uint32_t CSTOP4 : 1;   // [4..4] GPT4 Channel Stop (1=Stop, 0=No effect)
  uint32_t CSTOP5 : 1;   // [5..5] GPT5 Channel Stop (1=Stop, 0=No effect)
  uint32_t CSTOP6 : 1;   // [6..6] GPT6 Channel Stop (1=Stop, 0=No effect)
  uint32_t CSTOP7 : 1;   // [7..7] GPT7 Channel Stop (1=Stop, 0=No effect)
  uint32_t CSTOP8 : 1;   // [8..8] GPT8 Channel Stop (1=Stop, 0=No effect)
  uint32_t CSTOP9 : 1;   // [9..9] GPT9 Channel Stop (1=Stop, 0=No effect)
  uint32_t CSTOP10 : 1;  // [10..10] GPT10 Channel Stop (1=Stop, 0=No effect)
  uint32_t CSTOP11 : 1;  // [11..11] GPT11 Channel Stop (1=Stop, 0=No effect)
  uint32_t CSTOP12 : 1;  // [12..12] GPT12 Channel Stop (1=Stop, 0=No effect)
  uint32_t CSTOP13 : 1;  // [13..13] GPT13 Channel Stop (1=Stop, 0=No effect)
  uint32_t : 18;         // [14..31] Reserved
} T_gtstp_bits;

typedef union
{
  uint32_t     reg;
  T_gtstp_bits bf;
} T_reg_GTSTP;

// Macros for _Set_pwm_pin_output_mode function
#define FL_PHASE_PULL_UP     1
#define FL_PHASE_PULL_DOWN   2
#define FL_PHASE_Z_STATE     3
#define FL_PHASE_PWM_ON      4

// Phase output state constants for _Set_phase_output_state function
#define PHASE_OUTPUT_DISABLE 0  // High impedance state (coast mode) - both switches OFF
#define PHASE_OUTPUT_ENABLE  1

// Macros for _Set_pwm_level function
#define GPT_COUNT_DIR_DOWN   0
#define GPT_COUNT_DIR_UP     1

// PWM percentage constants for enhanced PWM control using GTUDDTYC register
#define PWM_PERCENT_MIN      0    // 0% duty cycle
#define PWM_PERCENT_MAX      100  // 100% duty cycle

#define DRIVER_COUNT          2    // Number of motors in the system
#define PHASE_COUNT          3    // Number of phases per motor

// Enumeration for ADC trigger module selection
typedef enum
{
  PWM_ADC0_TRIGGER = 0,  // Use GPT0 for ADC0 trigger generation
  PWM_ADC1_TRIGGER = 1   // Use GPT4 for ADC1 trigger generation
} T_pwm_adc_trigger_select;

extern volatile uint8_t gpt0_out_mode;
extern volatile uint8_t gpt1_out_mode;
extern volatile uint8_t gpt2_out_mode;
extern volatile uint8_t gpt3_out_mode;  // Motor Driver 2 Phase U
extern volatile uint8_t gpt4_out_mode;  // Motor Driver 2 Phase V
extern volatile uint8_t gpt5_out_mode;  // Motor Driver 2 Phase W

// Global phase state arrays for diagnostic access
// Index: [motor][phase]
extern volatile uint8_t g_phase_state_0_percent[DRIVER_COUNT][PHASE_COUNT];   // 0% duty state: GTIOA=LOW, GTIOB=HIGH
extern volatile uint8_t g_phase_state_100_percent[DRIVER_COUNT][PHASE_COUNT]; // 100% duty state: GTIOA=HIGH, GTIOB=LOW
extern volatile uint8_t g_phase_state_pwm_mode[DRIVER_COUNT][PHASE_COUNT];    // PWM mode: both force modes disabled
extern volatile uint8_t g_phase_state_Z_stage[DRIVER_COUNT][PHASE_COUNT];     // Z-state: both signals LOW (high impedance)

// Global structure for PWM and output state control for all phases
// This structure must be defined in Motor_Driver_task.c
// and updated by the motor control task

typedef struct
{
  uint32_t pwm_level[DRIVER_COUNT][PHASE_COUNT];     // [motor][phase] PWM level in steps (0..PWM_STEP_COUNT)
  uint8_t  output_state[DRIVER_COUNT][PHASE_COUNT];  // [motor][phase] Output enable flag (0=switches OFF, 1=switches enabled)
} T_pwm_phase_control;

extern T_pwm_phase_control g_pwm_phase_control;

uint32_t    Init_PWM_triangle_buffered(uint32_t freq);
void        PWM_start(void);
void        PWM_stop(void);
void        Pwm_update_all_phases_callback(void);

#endif  // PWM_TIMER_DRIVER_H
